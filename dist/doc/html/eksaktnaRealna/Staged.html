<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Staged</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Staged.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">eksaktnaRealna-0.1.0.0: Exact real arithmetics</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe-Inferred</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Staged</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>A staged computation is a sequence of approximations which represents its limit. Specifically,
  we think of modeling a topological space as a subspace of a continuous domain with a countable
  base, for theoretical background see the paper http:/<em>dx.doi.org</em>10.1016/j.apal.2008.09.025 (also
  available at http:/<em>math.andrej.com</em>)</p><p>Suppose we would like to represent a space X, where X is some sort of a complete space (either
  metrically or domain-theoretically complete). We think of the points of X as limits of sequences
  of approximations. For example, a real number may be thought of as a sequence of intervals which
  all contain x and whose widths converge to 0. In the general case the approximations can be
  abstract entities that need not correspond to intervals (although each approximation naturally
  corresponds to the subset of those points that it approximates.) The approximations are naturally
  order by how well they approximate the values (for intervals this is reverse inclusion) and they form
  a <em>base</em> for a continuous domain, see the cited paper above.</p><p>If <code>b</code> (&quot;b&quot; for the &quot;base&quot;) is the datatype which represents the approximations, then the elements
  of the space could be represented by the datatype <code>Int -&gt; b</code>. However, in practice we need to
  control the direction of approximation: a real number may be rounded up or down, a set may be
  approximated from inside or from outside, etc. Thus we include rounding information in the
  sequence, so that an element of the space is represented by the datatype <code><code><a href="Staged.html#t:Stage">Stage</a></code> -&gt; b</code> where
  <code><a href="Staged.html#t:Stage">Stage</a></code> carries rounding information and the index.</p><p>We empahsize that the rounding mode is <em>not</em> that of floating point arithmetic. Rather, it tells
  us whether the exact results should be approximated from below or above in the natural order of
  approximations. Typically, computations based on domain-theoretic models always approximate from
  below, but there are uses for over-approximations as well, for example when we estimate the truth
  value of a quantifier. Therefore we allow approximating sequences which approach their limit from
  above in the domai-theoretic order.</p><p>It is cumbersome to work with the datatype <code>Stage -&gt; b</code> explicitly because we need to manually pass
  around the <code>Stage</code> parameter. Haskell comes in handy here, as we define a monad which is very much
  like the <code>Reader</code> monad of Haskell.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span> <a href="#t:RoundingMode">RoundingMode</a><ul class="subs"><li>= <a href="#v:RoundUp">RoundUp</a></li><li>| <a href="#v:RoundDown">RoundDown</a></li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:Stage">Stage</a> = <a href="#v:Stage">Stage</a> {<ul class="subs"><li><a href="#v:precision">precision</a> :: <a href="file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a></li><li><a href="#v:rounding">rounding</a> :: <a href="Staged.html#t:RoundingMode">RoundingMode</a></li></ul>}</li><li class="src short"><a href="#v:anti">anti</a> :: <a href="Staged.html#t:Stage">Stage</a> -&gt; <a href="Staged.html#t:Stage">Stage</a></li><li class="src short"><a href="#v:prec_down">prec_down</a> :: <a href="file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a> -&gt; <a href="Staged.html#t:Stage">Stage</a></li><li class="src short"><a href="#v:prec_up">prec_up</a> :: <a href="file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a> -&gt; <a href="Staged.html#t:Stage">Stage</a></li><li class="src short"><a href="#v:prec">prec</a> :: <a href="Staged.html#t:RoundingMode">RoundingMode</a> -&gt; <a href="file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a> -&gt; <a href="Staged.html#t:Stage">Stage</a></li><li class="src short"><span class="keyword">class</span> (<a href="file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Functor">Functor</a> m, <a href="file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m) =&gt; <a href="#t:Completion">Completion</a> m <span class="keyword">where</span><ul class="subs"><li><a href="#v:get_stage">get_stage</a> :: m <a href="Staged.html#t:Stage">Stage</a></li><li><a href="#v:get_rounding">get_rounding</a> :: m <a href="Staged.html#t:RoundingMode">RoundingMode</a></li><li><a href="#v:get_prec">get_prec</a> :: m <a href="file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a></li><li><a href="#v:approximate">approximate</a> ::  m t -&gt; <a href="Staged.html#t:Stage">Stage</a> -&gt; t</li><li><a href="#v:limit">limit</a> ::  (<a href="Staged.html#t:Stage">Stage</a> -&gt; t) -&gt; m t</li><li><a href="#v:embed">embed</a> ::  t -&gt; m t</li><li><a href="#v:lift1">lift1</a> ::  (<a href="Staged.html#t:Stage">Stage</a> -&gt; t -&gt; u) -&gt; m t -&gt; m u</li><li><a href="#v:lift2">lift2</a> ::  (<a href="Staged.html#t:Stage">Stage</a> -&gt; t -&gt; u -&gt; v) -&gt; m t -&gt; m u -&gt; m v</li></ul></li><li class="src short"><span class="keyword">newtype</span> <a href="#t:Staged">Staged</a> t = <a href="#v:Staged">Staged</a> {<ul class="subs"><li><a href="#v:approx">approx</a> :: <a href="Staged.html#t:Stage">Stage</a> -&gt; t</li></ul>}</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:RoundingMode" class="def">RoundingMode</a></p><div class="doc"><p>The rounding mode tells us whether we should under- or over-approximate the exact result.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:RoundUp" class="def">RoundUp</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:RoundDown" class="def">RoundDown</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:RoundingMode" class="caption collapser" onclick="toggleSection('i:RoundingMode')">Instances</p><div id="section.i:RoundingMode" class="show"><table><tr><td class="src"><a href="file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/base-4.7.0.1/Data-Eq.html#t:Eq">Eq</a> <a href="Staged.html#t:RoundingMode">RoundingMode</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/base-4.7.0.1/Text-Show.html#t:Show">Show</a> <a href="Staged.html#t:RoundingMode">RoundingMode</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Stage" class="def">Stage</a></p><div class="doc"><p>A stage of computation tells us how hard we should try to compute the result. The <code>stage</code> component
 is a measure of precisions. As it goes to infinity, the approximation should converge to the exact
 value (in the sense of Scott topology on the underlying domain model).</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Stage" class="def">Stage</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:precision" class="def">precision</a> :: <a href="file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:rounding" class="def">rounding</a> :: <a href="Staged.html#t:RoundingMode">RoundingMode</a></dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:Stage" class="caption collapser" onclick="toggleSection('i:Stage')">Instances</p><div id="section.i:Stage" class="show"><table><tr><td class="src"><a href="file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/base-4.7.0.1/Text-Show.html#t:Show">Show</a> <a href="Staged.html#t:Stage">Stage</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:anti" class="def">anti</a> :: <a href="Staged.html#t:Stage">Stage</a> -&gt; <a href="Staged.html#t:Stage">Stage</a></p><div class="doc"><p><code><a href="Staged.html#v:anti">anti</a></code> reverses the rounding mode</p></div></div><div class="top"><p class="src"><a name="v:prec_down" class="def">prec_down</a> :: <a href="file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a> -&gt; <a href="Staged.html#t:Stage">Stage</a></p><div class="doc"><p><code>prec_down k</code> sets precision to <code>k</code> and the rounding mode to <code><a href="Staged.html#v:RoundDown">RoundDown</a></code></p></div></div><div class="top"><p class="src"><a name="v:prec_up" class="def">prec_up</a> :: <a href="file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a> -&gt; <a href="Staged.html#t:Stage">Stage</a></p><div class="doc"><p><code>prec_up k</code> sets precision to <code>k</code> and the rounding mode to <code><a href="Staged.html#v:RoundUp">RoundUp</a></code></p></div></div><div class="top"><p class="src"><a name="v:prec" class="def">prec</a> :: <a href="Staged.html#t:RoundingMode">RoundingMode</a> -&gt; <a href="file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a> -&gt; <a href="Staged.html#t:Stage">Stage</a></p><div class="doc"><p><code>prec r k</code> is the stage with given rounding <code>r</code> and precision <code>k</code></p></div></div><div class="top"><p class="src"><span class="keyword">class</span> (<a href="file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Functor">Functor</a> m, <a href="file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> m) =&gt; <a name="t:Completion" class="def">Completion</a> m <span class="keyword">where</span></p><div class="doc"><p>The <code><a href="Staged.html#t:Completion">Completion</a></code> class represents a completion operation. An instance <code>m</code> of class <code><a href="Staged.html#t:Completion">Completion</a></code>
   is a type constructor which takes a type <code>b</code> representing the base, i.e., the approximations, and
   gives the type <code>m b</code> of the completion of <code>b</code>. For example, if <code>b</code> is the datatype of dyadic
   intervals, then <code>m b</code> would be the interval domain.</p><p>Each element of the completion <code>m b</code> may be converted to a sequence of approximations with the
   &quot;approximate&quot; function. Conversely, a sequence of approximations may be converted to the element
   with the &quot;limit&quot; function.</p></div><div class="subs minimal"><p class="caption">Minimal complete definition</p><p class="src"><a href="Staged.html#v:get_stage">get_stage</a>, <a href="Staged.html#v:get_rounding">get_rounding</a>, <a href="Staged.html#v:get_prec">get_prec</a>, <a href="Staged.html#v:approximate">approximate</a>, <a href="Staged.html#v:limit">limit</a></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:get_stage" class="def">get_stage</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: m <a href="Staged.html#t:Stage">Stage</a></td><td class="doc"><p>get the current stage</p></td></tr></table></div><p class="src"><a name="v:get_rounding" class="def">get_rounding</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: m <a href="Staged.html#t:RoundingMode">RoundingMode</a></td><td class="doc"><p>get the current rounding</p></td></tr></table></div><p class="src"><a name="v:get_prec" class="def">get_prec</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: m <a href="file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a></td><td class="doc"><p>get the current precision</p></td></tr></table></div><p class="src"><a name="v:approximate" class="def">approximate</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: m t</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; <a href="Staged.html#t:Stage">Stage</a> -&gt; t</td><td class="doc"><p>approximate by a chain (from above or from below, depending on rounding mode)</p></td></tr></table></div><p class="src"><a name="v:limit" class="def">limit</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: (<a href="Staged.html#t:Stage">Stage</a> -&gt; t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; m t</td><td class="doc"><p>the element represented by a given chain</p></td></tr></table></div><p class="src"><a name="v:embed" class="def">embed</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: t</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">-&gt; m t</td><td class="doc"><p>a synonym for <code>return</code></p></td></tr></table></div><p class="src"><a name="v:lift1" class="def">lift1</a> ::  (<a href="Staged.html#t:Stage">Stage</a> -&gt; t -&gt; u) -&gt; m t -&gt; m u</p><div class="doc"><p>lift a map from approximations to points</p></div><p class="src"><a name="v:lift2" class="def">lift2</a> ::  (<a href="Staged.html#t:Stage">Stage</a> -&gt; t -&gt; u -&gt; v) -&gt; m t -&gt; m u -&gt; m v</p><div class="doc"><p>lift a map of two arguments from approximations to points.</p></div></div><div class="subs instances"><p id="control.i:Completion" class="caption collapser" onclick="toggleSection('i:Completion')">Instances</p><div id="section.i:Completion" class="show"><table><tr><td class="src"><a href="Staged.html#t:Completion">Completion</a> <a href="Staged.html#t:Staged">Staged</a></td><td class="doc"><p><code><a href="Staged.html#t:Staged">Staged</a></code> is an instance of a completion.</p></td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">newtype</span> <a name="t:Staged" class="def">Staged</a> t</p><div class="doc"><p>If <code>t</code> is the type of approximations then, <code>Staged t</code> is the type of the points of the space,
 represented as sequences of approximations.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Staged" class="def">Staged</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:approx" class="def">approx</a> :: <a href="Staged.html#t:Stage">Stage</a> -&gt; t</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:Staged" class="caption collapser" onclick="toggleSection('i:Staged')">Instances</p><div id="section.i:Staged" class="show"><table><tr><td class="src"><a href="file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> <a href="Staged.html#t:Staged">Staged</a></td><td class="doc"><p>The monad structure of <code><a href="Staged.html#t:Staged">Staged</a></code> is the same as that of the <code>Reader</code> monad.</p></td></tr><tr><td class="src"><a href="file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Functor">Functor</a> <a href="Staged.html#t:Staged">Staged</a></td><td class="doc"><p>The functor structure of <code><a href="Staged.html#t:Staged">Staged</a></code> is the same as that of the <code>Reader</code> monad.</p></td></tr><tr><td class="src"><a href="file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/base-4.7.0.1/Text-Show.html#t:Show">Show</a> <a href="Space.html#t:Sigma">Sigma</a></td><td class="doc"><p>The Show instance may cause divergence because <code><a href="Space.html#v:force">force</a></code> could diverge. An alternative
 implementation would give up after a while, and the user would have to use <code><a href="Space.html#v:force">force</a></code> explicitly to
 get the exact results (or divergence).</p></td></tr><tr><td class="src"><a href="Staged.html#t:Completion">Completion</a> <a href="Staged.html#t:Staged">Staged</a></td><td class="doc"><p><code><a href="Staged.html#t:Staged">Staged</a></code> is an instance of a completion.</p></td></tr><tr><td class="src"><a href="Interval.html#t:IntervalDomain">IntervalDomain</a> q =&gt; <a href="file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/base-4.7.0.1/Data-Eq.html#t:Eq">Eq</a> (<a href="Reals.html#t:RealNum">RealNum</a> q)</td><td class="doc"><p>It is a bad idea to use Haskell-style inequality <code>/=</code> on reals because it either returns <code>True</code>
 or it diverges. Similarly, using Haskell equality <code>==</code> is bad. Nevertheless, we define <code>==</code> and <code>/=</code>
 because Haskell wants them for numeric types.</p></td></tr><tr><td class="src"><a href="Interval.html#t:IntervalDomain">IntervalDomain</a> q =&gt; <a href="file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/base-4.7.0.1/Prelude.html#t:Floating">Floating</a> (<a href="Reals.html#t:RealNum">RealNum</a> q)</td><td class="doc"><p>Instance floating for reals uses Taylor's series and error bounds. (Missing: Atanh, Atan, Acos, Acosh)
 Functions (Cos, Sin, Exp, Tan, Cosh, Sinh) makes good approximations in short time for elements inside 
 the interval (-30,30) and for integers. Log is defined for elements inside (0,2) and Asinh for elements 
 inside (-1,1). For more details see http:/<em>www.diva-portal.org</em>smash<em>get</em>diva2:310454/FULLTEXT01.pdf                                     </p></td></tr><tr><td class="src">(<a href="Dyadic.html#t:ApproximateField">ApproximateField</a> q, <a href="Interval.html#t:IntervalDomain">IntervalDomain</a> q) =&gt; <a href="file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/base-4.7.0.1/Prelude.html#t:Fractional">Fractional</a> (<a href="Reals.html#t:RealNum">RealNum</a> q)</td><td class="doc"><p>Division and reciprocals.</p></td></tr><tr><td class="src">(<a href="Dyadic.html#t:ApproximateField">ApproximateField</a> q, <a href="Interval.html#t:IntervalDomain">IntervalDomain</a> q) =&gt; <a href="file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/base-4.7.0.1/Prelude.html#t:Num">Num</a> (<a href="Reals.html#t:RealNum">RealNum</a> q)</td><td class="doc"><p>The ring structure fo the reals.</p></td></tr><tr><td class="src"><a href="Interval.html#t:IntervalDomain">IntervalDomain</a> q =&gt; <a href="file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/base-4.7.0.1/Data-Ord.html#t:Ord">Ord</a> (<a href="Reals.html#t:RealNum">RealNum</a> q)</td><td class="doc"><p>Real numbers are an ordered type in the sense of Haskells <code><a href="file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/base-4.7.0.1/Data-Ord.html#t:Ord">Ord</a></code>, although a comparison never
 returns <code>EQ</code> (instead it diverges). This is a fact of life, comparison of reals is not decidable.</p></td></tr><tr><td class="src"><a href="Dyadic.html#t:ApproximateField">ApproximateField</a> q =&gt; <a href="file://C:\Program Files\Haskell Platform\2014.2.0.0\lib/../doc/html/libraries/base-4.7.0.1/Text-Show.html#t:Show">Show</a> (<a href="Reals.html#t:RealNum">RealNum</a> q)</td><td class="doc"><p>We implement a very simple show instance for reals which computes the 20th approximation
 and shows it as an interval, together with a floating point approximation.</p></td></tr><tr><td class="src"><a href="Interval.html#t:IntervalDomain">IntervalDomain</a> q =&gt; <a href="Space.html#t:LinearOrder">LinearOrder</a> (<a href="Reals.html#t:RealNum">RealNum</a> q)</td><td class="doc"><p>Linear order on real numbers</p></td></tr><tr><td class="src"><a href="Interval.html#t:IntervalDomain">IntervalDomain</a> q =&gt; <a href="Space.html#t:Hausdorff">Hausdorff</a> (<a href="Reals.html#t:RealNum">RealNum</a> q)</td><td class="doc"><p>The Hausdorff property</p></td></tr><tr><td class="src"><a href="Interval.html#t:IntervalDomain">IntervalDomain</a> q =&gt; <a href="Space.html#t:Overt">Overt</a> (<a href="Reals.html#t:ClosedInterval">ClosedInterval</a> q) (<a href="Reals.html#t:RealNum">RealNum</a> q)</td><td class="doc"><p>Overtness of reals, open interval (a,b) and closed interval [a,b]</p></td></tr><tr><td class="src"><a href="Interval.html#t:IntervalDomain">IntervalDomain</a> q =&gt; <a href="Space.html#t:Compact">Compact</a> (<a href="Reals.html#t:ClosedInterval">ClosedInterval</a> q) (<a href="Reals.html#t:RealNum">RealNum</a> q)</td><td class="doc"><p>Compactness of the closed interval</p></td></tr></table></div></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.3</p></div></body></html>